// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: batch.go

package database

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createBulkTrackPlaylist = `-- name: CreateBulkTrackPlaylist :batchexec
INSERT INTO playlist_track (
    playlist_id, track_id
) VALUES (
    $1, $2
)
`

type CreateBulkTrackPlaylistBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateBulkTrackPlaylistParams struct {
	PlaylistID int64
	TrackID    int64
}

func (q *Queries) CreateBulkTrackPlaylist(ctx context.Context, arg []CreateBulkTrackPlaylistParams) *CreateBulkTrackPlaylistBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.PlaylistID,
			a.TrackID,
		}
		batch.Queue(createBulkTrackPlaylist, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateBulkTrackPlaylistBatchResults{br, len(arg), false}
}

func (b *CreateBulkTrackPlaylistBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateBulkTrackPlaylistBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createBulkTracks = `-- name: CreateBulkTracks :batchone
INSERT INTO tracks (
    title, artist, img_small_url, img_medium_url, img_large_url,
    release_date, spotify_id, duration_ms, preview_url, popularity
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) ON CONFLICT (spotify_id) DO UPDATE SET
    title = EXCLUDED.title,
    artist = EXCLUDED.artist,
    img_small_url = EXCLUDED.img_small_url,
    img_medium_url = EXCLUDED.img_medium_url,
    img_large_url = EXCLUDED.img_large_url,
    release_date = EXCLUDED.release_date,
    duration_ms = EXCLUDED.duration_ms,
    preview_url = EXCLUDED.preview_url,
    popularity = EXCLUDED.popularity,
    updated_at = NOW()
RETURNING id
`

type CreateBulkTracksBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateBulkTracksParams struct {
	Title        string
	Artist       string
	ImgSmallUrl  pgtype.Text
	ImgMediumUrl pgtype.Text
	ImgLargeUrl  pgtype.Text
	ReleaseDate  pgtype.Date
	SpotifyID    string
	DurationMs   int32
	PreviewUrl   pgtype.Text
	Popularity   int16
}

func (q *Queries) CreateBulkTracks(ctx context.Context, arg []CreateBulkTracksParams) *CreateBulkTracksBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Title,
			a.Artist,
			a.ImgSmallUrl,
			a.ImgMediumUrl,
			a.ImgLargeUrl,
			a.ReleaseDate,
			a.SpotifyID,
			a.DurationMs,
			a.PreviewUrl,
			a.Popularity,
		}
		batch.Queue(createBulkTracks, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateBulkTracksBatchResults{br, len(arg), false}
}

func (b *CreateBulkTracksBatchResults) QueryRow(f func(int, int64, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var id int64
		if b.closed {
			if f != nil {
				f(t, id, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&id)
		if f != nil {
			f(t, id, err)
		}
	}
}

func (b *CreateBulkTracksBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
